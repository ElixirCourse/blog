---
category: Проект
author: ivanivanoff
tags:
  - elixir
  - project
---

# Elixir курсов проект

Disclaimer: За да пропуснете празните приказки и да видите самото условие на проекта  вижте **Условие**

### Какъв проект и защо сега?
За който не е разбрал - освен домашни и финален проект, то вие трябва да напишете и един малък проект в средата на семестъра. За разлика от домашните, тук няма да ви дадем списък с функции, които да имплементирате, тестове, с които да проверите коректността и т.н. Мисията да направите дизайна, да решите как ще изглежда публичния интерфейс на програмата и **да напишете тестове** е изцяло ваша.

В днешно време голяма част от информацията в web пространството се предава чрез JSON. Но също така JSON е текстов формат - няма как с него да постигнем оптимална скорост и размер. Затова на сцената се появява MsgPack - двоичен формат за сериализация, за който от [сайта](https://msgpack.org) прочитаме:
>It's like JSON. but fast and small.

Може би сте ни чували на лекции да казваме, че Erlang/Elixir са подходящи езици за обработка на binary data, а и за имплементация на комуникационни протоколи. Фактът, че Erlang е създаден с цел писане на телеком програми си казва думата. Сега e ваш ред да опитате да направите точно това.

### Условие

Вашата задача е да създадете mix проект, който предоставя функционалност за конвертиране JSON към MsgPack и MsgPack към JSON. Какви публични функции ще имате, какви аргументи ще приемат те, как ще е структуриран проектът - това са част от нещата, които трябва да решите сами. Също ваша важна задача е да напишете смислени и изчерпателни тестове.

Наша задача, като преподаватели в курса на Elixir, е да ви даваме насоки и да отговаряме на въпроси.

##### Какво е JSON?
 - Обяснено простичко - [линк](https://stackoverflow.com/a/383699)
 - RFC - [линк](https://tools.ietf.org/html/rfc7159)

##### Какво е MsgPack? 
 - Wikipedia - [линк](https://en.wikipedia.org/wiki/MessagePack)
 - Спецификация - [линк](https://github.com/msgpack/msgpack/blob/master/spec.md)
 
MsgPack е формат за сериализация на данни в двоичен формат.

MsgPack е JSON-compatible. ...A?
Това значи, че MsgPack дефинира точно тези типове, които дефинира и JSON, и може без загуба на информация да се конвертира между JSON и MsgPack ([за разлика](https://stackoverflow.com/a/6357042) от BSON). Как би изглеждало това във вашия код?
```elixir
msgpack_decoded_to_some_elixir_struct = decode_from_msg_pack(message)
json = encode_to_json(msgpack_decoded_to_some_elixir_struct)
```
Тоест не е нужно да правите допълнителни стъпки върху данните, за да ги подготвите.

##### Пример
Следният JSON с размер 27 байта
> {"compact":true,"schema":0}

конвертиран до MsgPack заема 18 байта (33% по-малко)и изглежда така:
> 82 a7 63 6f 6d 70 61 63 74 c3 a6 73 63 68 65 6d 61 00

За справки може да използвате [msgpack.org](https://msgpack.org/) и по-специално `Try!` секцията.

##### Неща, за които не изискваме да имплементирате поддръжка:
- unsigned integer
- float32
- fixed ext
- timestamp

##### Неща, които ще оценяваме:
- Функционалност - Проектът трябва да имплементира коректно поне част от условието.
- Тестове - "Тествах го като копирах един джейсън в конзолата и видях, че работи" не се приема. Искаме от вас да напишете смислени тестове. Опитайте се да покриете различни крайни случаи - празни аргументи, грешен формат и т.н.
- Стил - Това е субективната част в оценяването на проекта. Малка част от нещата, които включва са:
   - (не)използване на `if`/`cond`. Забележете, че това **не** значи, че трябва да направите `case` с `true ->` и `false ->`. Това означава, че може би трябва да подходите по различен начин към проблема.
   - Дизайн и архитектура на проекта:
     - *разумно* разделение на файловете в поддиректории (ако е нужно)  
     - *разумно* разделение на логиката в модулите
     - *разумно* използване на структури 
     - абе, все субективни неща...
   - Функционално, а не Х програмиране `when X in ["ООП", "императивно", ...]`. Elixir, а не X транслиран до Elixir `when X in ["Java","Ruby", "C++", "C#", ...]`
   - Имена на функции/променливи - `encode`/`pack` са добри имена за функция, `fun` не е.
   - Форматиране на кода - пускайте редовно `mix format`
   - Наличие на документация и тип-спецификации. Не е нужно и да прекалявате с документацията.
   - и други.

Преди датата за защита на проекта ще бъде публикувана скалата за оценка и колко точки ще носи всеки компонент.

PS 0: Бинарен протокол не е синоним на бързодействие - тези неща трябва да се измерят. Тази задача **не** влиза в условието на проекта, но ако ви остане време това е една чудесна възможност да видите как се случва benchmarking-ът в Elixir 

PS 1: Има много библиотеки, които имплементират условието. Не правете copy-paste на големи парчета код от тях. Може да не ви хванем, а може и да ви хванем.

PS2: Някой каза ли binary pattern matching?


