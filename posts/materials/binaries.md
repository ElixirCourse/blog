---
title_image_path: binaries.jpg
category: Програма
created_at: 2019-03-07T17:00:00
tags:
  - elixir
  - binaries
  - erlang
  - pattern matching
  - strings
---

# Двоични структури (Binaries)

В тази публикация ще се запознаем по-задълбочено с двоичните структури в _Elixir_, каква е вътрешната им репрезентация, как и за какво са ни полезни.

## Конструкция

Една _binary_ структура представлява поредица от битове (често поредица от байтове).
Дефинира се със следната конструкция:

```elixir
<<>>
#=> <<>>
```

В тази конструкция слагаме поредица от числа представляващи битове или байтове:

```elixir
<< 123, 23, 1 >>
#=> << 123, 23, 1 >>
```

Всяко число представлява един байт. В този ред на мисли, това е вярно:

```elixir
<< 0b01111011, 0b00010111, 0b00000001 >> == << 123, 23, 1 >>
#=> true
```

Числата винаги представляват един байт. Ако числото е по-голямо от **255**, то е "отрязано" до един байт.

```elixir
<< 280 >>
#=> <<24>>
```

Разбира се има начин числата да представляват повече от един байт. Това става с помощта на модификатора `size`.

```elixir
<< 280::size(16) >>
#=> << 1, 24 >>

# или

<< 280::16 >>
#=> << 1, 24 >>

<< 0b00000001, 0b00011000 >> == << 280::16 >>
#=> true
```

С този модификатор можем да представим число в `7` бита:

```elixir
<< 129::7 >>
#=> <<1::size(7)>> # Всъщност е отрязано от 10000001 - взимат се десните 7 бита - 0000001
```

Интересно е съхранението на числа с плаваща запетая като _binaries_.
Винаги се представят като двоична структура от **8** байта:

```elixir
<< 5.5::float >>
#=> <<64, 22, 0, 0, 0, 0, 0, 0>>
```

Това е така, защото числата с плаваща запетая в _Elixir_ са с _double_ прецизност или **64** битови.

```elixir
<<sign::1, exponent::11, mantissa::52>> = <<5.5::float>>
#=> <<64, 22, 0, 0, 0, 0, 0, 0>>
{sign, exponent, mantissa}
#=> {0, 1025, 1688849860263936}
```

## Функции и операции свързани с binaries

### Конкатенация

Възможно е да конкатенираме _binary_ структури с оператора `<>`.

```elixir
<< 83, 79, 83 >> <> << 24, 4 >>
#=> <<83, 79, 83, 24, 4>>
```

Друг начин за конкатенация е:

```elixir
<< 83, 79, 83, << 24, 4 >> >>
#=> <<83, 79, 83, 24, 4>>
```

Този код е аналогичен на примера с оператора `<>`.

### Размер

В паметта, за _binary_ структурите, има мета-информация, която съхранява дължината им.
Това значи, че пресмятането на дължината на _binary_ структура е операция с константа сложност.
Поради това и функцията за намиране на дължината на двоична структура има в името си `size`:

```elixir
byte_size(<< 83, 79, 83 >>)
#=> 3
```

Когато боравим с битове, чийто брой не е кратен на **8**, ще се закръгли нагоре:

```elixir
byte_size(<< 34::5, 23::2, 12::2 >>)
#=> 2

# Между другото:
<< 34::5, 23::2, 12::2 >> == << 22, 0::1 >>
#=> true
```

Разбира се можем да видим и точната дължина в битове, което е отново **O(1)** операция:

```elixir
bit_size(<< 34::5, 23::2, 12::2 >>)
#=> 9
```

### Проверки

Има два начина за проверяване дали типа на дадена променлива е поредица от битове.

1. `Kernel.is_bitstring/1` - Истина за всяка валидна _binary_ структура.
2. `Kernel.is_binary/1` - Истина е само ако `bit_size/1` връща число кратно на **8** - тоест структурата е поредица от байтове.

В повечето случаи ще използваме `Kernel.is_binary/1`.

### Sub-binaries

С функцията `Kernel.binary_part/3` можем да боравим с части от дадена _binary_ стойност:

```elixir
binary_part(<< 83, 79, 83, 23, 21, 12 >>, 1, 3)
#=> <<79, 83, 23>>
```

Взима под-структура от индекс - втория аргумент с брой елементи - третия. Очаквайте
`ArgumentError`, ако тези аргументи са невалидни индекс и/или дължина за дадената структура.

Важното тук е, че това е бърза операция - нищо не се копира, просто получавате указател
от дадено място в паметта, с дадена дължина.

## Pattern matching

В _Elixir_ можем да съпоставяме и _binaries_:

```elixir
<< x, y, x >> = << 83, 79, 83 >>
#=> "SOS"

x
#=> 83

y
#=> 79
```

Друга интересна възможност е да съпоставим променлива към повече от един байт.

```elixir
<< x, y, z::binary >> = << 83, 79, 83, 43, 156 >>
#=> <<83, 79, 83, 43, 156>>
z
#=> << 83, 43, 156 >>

# Ако не добавим `::binary` автоматично съпоставя променлива на 1 байт:
<< x, y, z >> = << 83, 79, 83, 43, 156 >>
#=> ** (MatchError) no match of right hand side value: <<83, 79, 83, 43, 156>>
```

Ето пример за разделяне и изваждане на частите на число с плаваща запетая,
така както е [представено](https://en.wikipedia.org/wiki/Double-precision_floating-point_format):

```elixir
<< sign::size(1), exponent::size(11), mantissa::size(52) >> = << 4815.162342::float >>
#=> <<64, 178, 207, 41, 143, 62, 204, 196>>

sign
#=> 0
```

Тук знакът е **1** при отрицателно число и **0** при положително - в случая е **0**.
Пази се в един бит.

Цялото число може да се пресметне с **(-1)<sup>sign</sup>(1 + mantissa/2<sup>52</sup>)2<sup>exponent - 1023</sup>**:

```elixir
:math.pow(-1, sign) * (1 + mantissa / :math.pow(2, 52)) * :math.pow(2, exponent - 1023)
#=> 4815.162342
```

Освен `float` и `binary` модификаторите, има `integer` модификатор, който се прилага
автоматично ако никой друг не е използван.
Модификаторът `bytes` е аналогичен на `binary`.
Модификаторите `bits` и `bitstrig` се използват за съпоставяне на битстринг съдържание - поредица
от битове с неопределена дължина.

```elixir
<< x::5, y::bits >> = << 225 >>
#=> <<225>>

x
#=> 28

y
#=> <<1::size(3)>>
```

Модификаторите `bitstrig` и `binary` без дължина могат да се използват само в края на _binary_ структурата.

Останалите възможни модификатори са `utf8`, `utf16` и `utf32`, които са свързани с _unicode_.
Ще се върнем към `utf8`, когато си говорим за низове в следващата публикация.

Интересно нещо, свързано с модификаторите, е, че `size` работи с тях.
`size` задава дължина в битове, когато работим с `integer`, но ако работим
с `binary` модификатор, `size` е в байтове:

```elixir
<< x::binary-size(4), _::binary >> = << 83, 222, 0, 345, 143, 87 >>
#=> <<83, 222, 0, 89, 143, 87>>

x # 4 байта
#=> <<83, 222, 0, 89>>
```

## Имплементация

Всеки процес в _Elixir_ има собствен _heap_.
В тази памет се съхраняват различни структури от данни и стойности.
Когато два процеса си комуникират, съобщенията, които се изпращат между тях, се копират в _heap_-овете им.

Когато си говорим за _binaries_, обаче, има една голяма разлика с този модел.
Ако _binary_-то е **64 байта** или по-малко, то се съхранява в _heap_-a на процеса си и се копира при размяна с друг процес, както е описано по-горе.
Такива _binary_ структури наричаме **heap binaries**.

Когато структурата ни е по-голяма от **64 байта**, тя не се пази в _process heap_-a. Пази се в обща памет за всички процеси на даден _node_ (Erlang виртуална машина). В _process heap_-a се пази малък обект, наречен **ProcBin**, който е указател към даденото _binary_, съхранено в общия _heap_. В този общ _heap_, _binary_ структура може да бъде сочена от множество такива _ProcBin_ указатели от множество процеси. Има _reference counter_ за всеки от тези указатели. Когато той стане **0**, _Garbage Collector_-ът ще може да изчисти _binary_-то от общия _heap_.
Такива _binary_ структури наричаме **refc binaries**.

Защо това е хубаво? Защото при по-големи двоични структури няма постоянно копиране
между процесите и съществуват различни оптимизации.
Разбира се, трябва да се внимава с тези _refc binaries_.

Говорейки си за имплементацията е хубаво да обърнем внимание на два вида специални указатели, свързани с двоичните структури.

По-горе споменахме _sub binary_ стойностите, получен чрез `Kernel.binary_part/3`, която вътрешно ползва `:erlang.split_binary/2`.
Това е специален указател който сочи към част от дадено _binary_. Няма копиране (защото всичко е _immutable_). Създаването на _sub binary_ е евтина операция, но ако става въпрос за _refc binary_, _reference counter_-a се увеличава.

Друг специален обект е _match context_-ът. Той е подобен на _sub binary_, но оптимизиран за*binary pattern matching*. Държи указател към двоичните данни в паметта, и когато нещо е _match_-нато, указателят се придвижва напред. Компилаторът отлага създаването на _sub binary_ за всяка _match_-ната променлива, ако е възможно, и преизползва един и същ _match context_.

### Оптимизации при конкатенация

Да видим как работи конкатенацията, когато сме запознати с модела на пазене на двоичните структури в паметта.
Имаме следния код:

```elixir
x = << 83, 222, 0, 89 >>
y = << x, 225, 21 >>
z = << y, 125, 156 >>
a = << y, 15, 16, 19 >>
```

Нека обясним всеки ред в този пример.

На първия ред виждаме, че `x` сочи към ново _binary_, което е **4** байта, следователно се създава в _heap_-a на текущия процес.

Вторият ред представлява конкатенация.
Към `x` се добавят още **2** байта и това ново _binary_ се присвоява на `y`.
Какво става с паметта?
Операцията за добавяне всъщност създава ново _refc binary_. Така е имплементирана. В общата памет се заделя място с големина `max(2 * byte_size(x), 256)`, в случая - **256** байта:

```
[4] -> |83|222|0|89| | | | |...| -> 256 байта
```

Този указател е създаден в _heap_-a на текущия процес, също _heap binary_-то за `x`, което беше създадено на първия ред, сега може да бъде изчистено от _Garbage Collector_-a на процеса си. Байтовете, които трябва да се добавят са добавени в свободното пространство:

```
[4] -> |83|222|0|89|225|21| | |...| -> 256 байта
[6] -^
```

Какво става на **3**-ти ред?
Искаме да добавим към `y` още **2** байта и да присвоим на `z` резултата. Тъй като след байтовете на `y` има свободно място, те се преизползват за `z`. Няма копиране, защото всичко е _immutable_, от което следва че може да се преизползва всичко, когато е възможно:

```
[4] -> |83|222|0|89|225|21|125|156| | | |...| -> 256 байта
[6] -^
[8] -^
```

Сега става интересно.
На **4**-ти ред искаме да добавим към `y` **3** байта и да присвоим резултата към `a`. Сега след стойността на `y`, в паметта има данни и не можем да преизползваме пространството. Затова _run-time_ системата, копира стойността на `y` на ново място в паметта (използва формулата по-горе) и добавя _3_-те нови байта там:

```
[4] -> |83|222|0|89|225|21|125|156| | | |...| -> 256 байта
[6] -^
[8] -^

[9] -> |83|222|0|89|225|21|15|16|19| | |...| -> 256 байта
```

Тази оптимизация е възможна в доста малко случаи. Има операции, които карат паметта да стане компактна и да освободи неизползваните байтове, от което следва че подобна оптимизация при добавяне ще е невъзможна. Такива операции са пращането на _binary_-то като съобщение между процеси, както и създаването на _match context_ при _pattern matching_.

С този последен пример завършваме тази публикация.
Показахме ви _binary_ структурите в по-голяма дълбочина преди да говорим за низове. Почти всичко казано не е специфично за _Elixir_ и идва от _Erlang_. Следващата статия ще разгледа низовете в дълбочина - ще си говорим за _unicode_ и _utf8_ и ще споменем някои от функциите в `String` модула.
