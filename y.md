title_image_path: spiral.png
category: Advanced
tags:
  - recursion
  - combinators
  - anonymous functions

--------

# Анонимни функции и рекурсия

В предните статии споменахме за рекурсия, а досега един пример не сме показали.
Знаем основните типове на езика, знаем как работи `pattern matching`-a и че всичко е `immutable`.
Можем да си пуснем `iex` и да интерпретираме кода си. С тези знания би трябвало
да е възможно да си дефинираме функцията която смята факториел, например.
Това е функционален език. Основите му трябва да са достатъчни, нали?

Отговорът не е толкова прост.
Да, достатъчни са, но ще трябва да се потрудим.

Нека да започнем.

## Факториел - Началото
Да започнем с това да дефинираме условието на факториел.
```elixir
factoriel.(0) = 1
factoriel.(1) = 1 * factoriel.(0)
factoriel.(2) = 2 * factoriel.(1)

.......

factoriel.(n) = n * factoriel.(n - 1)
```

Чудесно! Нека сега да дефинираме тази анонимна функция и да я присвоим към променливата `factoriel`:
```elixir
iex> factoriel = fn
...>   0 -> 1
...>   n -> n * factoriel.(n - 1)
...> end
  ** (CompileError) iex:4: undefined function factoriel/0
```

Нормално. `factoriel` не съществува, когато дефинираме функцията. Не можем да я
дефинираме. Няма как да дефинираме `factoriel` или която и да е рекурсивна функция,
като използваме само анонимни функции.

От друга страна можем да пробваме да направим така, че `factoriel` да е известна
при дефиниране. Как? Ами като се подаде на функция от по-висок ред като аргумент:

```elixir
iex> factoriel = fn (me) ->
...>   fn
...>     0 -> 1
...>     n -> n * me.(n - 1)
...>   end
...> end
#Function<6.52032458/1 in :erl_eval.expr/5>
```

Това сработи. Само че какво да му подадем за `me`? Ами нека пробваме с `factoriel`.
Нека подадем `factoriel` на `factoriel`:

```elixir
iex> factoriel.(factoriel)
#Function<6.52032458/1 in :erl_eval.expr/5>
```

Сработи. Върна функция. Може би тази функция е имплементацията на факториел?
Така изглежда, да пробваме:

```elixir
iex> factoriel.(factoriel).(0)
1
iex> factoriel.(factoriel).(1)
** (ArithmeticError) bad argument in arithmetic expression
```

Добре, за `0` сработи. Защо? Най-добре ще си го обясним ако разпишем какво
представлява функцията `factoriel.(factoriel)`:

```elixir
(fn (me) ->
  fn
    0 -> 1
    n -> n * me.(n - 1)
  end
end).(fn (me) ->
  fn
    0 -> 1
    n -> n * me.(n - 1)
  end
end)

=>

factoriel_factoriel = fn
  0 -> 1
  n -> n * (fn (me) ->
    fn
      0 -> 1
      n -> n * me.(n-1)
    end
  end).(n - 1)
end

=>

factoriel_factoriel.(0) # Просто е -> съпоставя се с 0 -> 1 и това е успешно:
1

factoriel_factoriel.(1) # Тук стигаме до n -> случая

=>

1 * (fn (me) ->
      fn
        0 -> 1
        n -> n * me.(n-1)
      end
    end).(0)

=>

1 * (fn
      0 -> 1
      n -> n * 0.(n-1)
    end)

# Това не може да се редуцира повече и получаваме
# число умножено по анонимна функция - ArithmeticError
```

Добре. Разбрахме защо за `0` работи, а за `1` - не. Сега като знаем какъв е проблемът,
нека помислим как да го решим.

## Факториел II - Завинаги

Как да променим `factoriel` за да работи в случая с `1`.
Нека изолираме само този случай. С `0` работи. Нека проработи с `1`.
Другите безкрайни на брой случаи ще ги оставим за после.

Да се върнем към редукцията която кръстихме `factoriel_factoriel`:

```elixir
factoriel_factoriel = fn
  0 -> 1
  n -> n * (fn (me) ->
    fn
      0 -> 1
      n -> n * me.(n-1)
    end
  end).(n - 1)
end

# Като подадяхме едно стигахме до следния случай:

1 * (fn (me) ->
      fn
        0 -> 1
        n -> n * me.(n-1)
      end
    end).(0)

```

Това не е ли `1 * factoriel.(0)`? А `factoriel.(0)` връща функция. От друга страна
`factoriel.(factoriel).(0)` е случаят който работи за `0`.
Добре тогава - нека някак направим така че вместо `1 * factoriel.(0)` да имаме `1 * factoriel.(factoriel).(0)`.

Отново да погледнем `factoriel`:

```elixir
factoriel = fn (me) ->
  fn
    0 -> 1
    n -> n * me.(n - 1)
  end
end
```

Когато подадем `factoriel` на `factoriel` в случая `1` видяхме че проблемът е,
че `me.(0)` (`me` при това извикване се заменя с `factoriel`) връща фунцкия,
а не факториел от `0`, и си казахме че `factoriel.(factoriel).(0)`, което
връща факториел от `0` ще помогне.

Това означава, че ако вместо `me.(n - 1)` имаме `me.(me).(n - 1)`, при извикване
на `factoriel.(factoriel).(1)` ще получим `1 * factoriel.(factoriel).(0)`, което
е `1*0!` или `1!`. Нека да пробваме:

```elixir
factoriel = fn (me) ->
  fn
    0 -> 1
    n -> n * me.(me).(n - 1)
  end
end

factoriel.(factoriel).(0) # 0!
1
factoriel.(factoriel).(1) # 1!
1
```

Успяхме, имаме `0!` и `1!`. Сега е време да помислим как да имплементираме `n!`.
Нека да пробваме с `2!`, да видим грешката и да разгърнем извикването, както направихме
с `factoriel.(factoriel).(1)` преди малко:
```elixir
factoriel.(factoriel).(2)
2
# А?! Това проработи? даже е 2*1*0! - 2!

factoriel.(factoriel).(3)
6 # 3!
factoriel.(factoriel).(5)
120 # 5!
factoriel.(factoriel).(10)
3628800 # 10!
```

Това е работещ факториел написан с анонимни функции. Това е рекурсия, написана
само с анонимни функции. Хмм. Какво направихме? Даже можем да го напишем без
да ползваме променливи така:
```elixir
(fn (me) ->
  fn
    0 -> 1
    n -> n * me.(me).(n - 1)
  end
end).(fn (me) ->
  fn
    0 -> 1
    n -> n * me.(me).(n - 1)
  end
end).(5)
120
```

Как работи това?

## Факториел III - Безкрайност

Нека да видим какво се случва с да речем `factoriel.(factoriel).(3)`.

```elixir
(fn (me) ->
  fn
    0 -> 1
    n -> n * me.(me).(n - 1)
  end
end).(fn (me) ->
  fn
    0 -> 1
    n -> n * me.(me).(n - 1)
  end
end).(3)

=>

(fn
  0 -> 1
  n -> n * (fn (me) ->
              fn
                0 -> 1
                n -> n * me.(me).(n - 1)
              end
            end).(fn (me) ->
              fn
                0 -> 1
                n -> n * me.(me).(n - 1)
              end
            end).(n - 1)
end).(3)

=>

3 * (fn (me) ->
      fn
        0 -> 1
        n -> n * me.(me).(n - 1)
      end
    end).(fn (me) ->
      fn
        0 -> 1
        n -> n * me.(me).(n - 1)
      end
    end).(2)

=>

3 * (fn
      0 -> 1
      n -> n * (fn (me) ->
                  fn
                    0 -> 1
                    n -> n * me.(me).(n - 1)
                  end
                  end).(fn (me) ->
                    fn
                      0 -> 1
                      n -> n * me.(me).(n - 1)
                    end
                  end).(n - 1)
      end).(2)

# Забелязвате как преди малко получихме една голяма функция f.(3),
# а сега пак я виждаме в 3 * f.(2)

=>

3 * 2 * (fn
          0 -> 1
          n -> n * (fn (me) ->
                      fn
                        0 -> 1
                        n -> n * me.(me).(n - 1)
                      end
                      end).(fn (me) ->
                        fn
                          0 -> 1
                          n -> n * me.(me).(n - 1)
                        end
                      end).(n - 1)
        end).(1)
# 3 * 2 * f.(1)

=>

3 * 2 * 1 * (fn
              0 -> 1
              n -> n * (fn (me) ->
                      fn
                        0 -> 1
                        n -> n * me.(me).(n - 1)
                      end
                      end).(fn (me) ->
                        fn
                          0 -> 1
                          n -> n * me.(me).(n - 1)
                        end
                      end).(n - 1)
            end).(0)

# 3 * 2 * 1 * f.(0), но тук ще съпоставим 0 на 0 -> 1 с успех и ще получим:

=>

3 * 2 * 1 * 1 = 6 # 3!
```

В общи линии достигнахме до повтаряща се функция, която се държи като факториел.
В този ред на мисли:

```elixir
factoriel = fn (me) ->
  fn
    0 -> 1
    n -> n * me.(me).(n - 1)
  end
end
```

Това беше грешно име за тази функция.
Ето я истинската дефиниция на `factoriel` като анонимна функция:

```elixir
factoriel = (fn (f) ->
  fn
    0 -> 1
    n -> n * f.(f).(n - 1)
  end
end).(fn (f) ->
  fn
    0 -> 1
    n -> n * f.(f).(n - 1)
  end
end)

iex> factoriel.(5)
120
```

И тук можем да спрем.

Но защо да не генерализираме малко тази конструкция, така
че да работи и за други функции на един аргумент - да речем Фибоначи. Като цяло
Използвайки тази идея можем да дефинираме функцията намираща `n`-тото число от редицата на Фибоначи така:

```elixir
fib = (fn (f) ->
  fn
    0 -> 1
    1 -> 2
    n -> f.(f).(n - 1) + f.(f).(n - 2)
  end
end).(fn (f) ->
  fn
    0 -> 1
    1 -> 2
    n -> f.(f).(n - 1) + f.(f).(n - 2)
  end
end)

iex> fib.(3)
5
```

## Факториел IV - Генерализации

Абстракцията е мого важна част от програмирането.
* Нека да пробваме да не повтаряме кода си, ако можем.
* Нека да преизползваме толкова код, колкото можем.

Първо няколко термина:

Ще наричаме функции които имат само свързани променливи комбинатори.
Това са функции които зависят само от променливи декларирани като техни аргументите или в телата им:
```elixir
id = fn (x) -> x end # Това е комбинатор - I комбинатор или identity комбинатор

y = 5
fn (x) -> x + y end # Това не е комбинатор - зависи от променлива, която не е дефинирана в аргументите ѝ - y.
```

Ще дефинираме един комбинатор, наречен Омега комбинатор или looping комбинатор:
```elixir
o = fn (f) -> f.(f) end

o.(id) == id
true
o.(id) == id.(id)
true
```

Да се върнем към нашия факториел:

```elixir
factoriel = (fn (f) ->
  fn
    0 -> 1
    n -> n * f.(f).(n - 1)
  end
end).(fn (f) ->
  fn
    0 -> 1
    n -> n * f.(f).(n - 1)
  end
end)

=>

factoriel = fn (g) ->
  g.(g)
end.(fn (f) ->
  fn
    0 -> 1
    n -> n * f.(f).(n - 1)
  end
end)
```

Да, факториелът е представен като извикване на тази прото-факториел функцийка със
себе си. С други думи:

```elixir
factoriel = o.(fn (f) ->
  fn
    0 -> 1
    n -> n * f.(f).(n - 1)
  end
end)
```

Нека да опитаме да извадим логиката специфична за факториела във функция,
която прилича на класическата дефиниция на факториел. Можем ли?

```elixir
factoriel = o.(fn (f) ->
  proto_factoriel = fn g ->
    fn
      0 -> 1
      n -> n * g.(n - 1)
    end
  end

  proto_factoriel.(fn (x) -> f.(f).(x) end)
end)
```

Сега изглежда по-сложно, но не е. Извадихме това, което прави факториела - факториел,
есенцията на имплементацията му в обособена `proto_factoriel` функция.
А защо направихме това? Защото е стъпка към целта - да изкараме есенцията на
факториела от конструкцията, която позволява рекурсия с анонимни функции.
Всъщност ние сме доста близко до тази цел. Следващата стъпка ще е да извадим `proto_factoriel` навън:

```elixir
proto_factoriel = fn g ->
  fn
    0 -> 1
    n -> n * g.(n - 1)
  end
end

factoriel = (fn (h) ->
  o.(fn (f) ->
    h.(fn (x) -> f.(f).(x) end)
  end)
end).(proto_factoriel)
```

Добре! Изваждането на една функция е лесно, просто обвиваме тялото на функцията
която я дефинира в друга функция, вадим дефиницията навън и я подаваме на обвиващата функция.
Сега имаме конструкцията, която ни позволява да построим рекурсия за анонимни функции с един аргумент.
Ето я и нея:


```elixir
fn (h) ->
  o.(fn (f) ->
    h.(fn (x) -> f.(f).(x) end)
  end)
end

=>

y = fn (h) ->
  (fn (f) ->
    f.(f)
  end).(fn (g) ->
    h.(fn (x) -> g.(g).(x) end)
  end)
end
```

Ето как с нея можем да си построим `fib` функцията:

```elixir
proto_fib = fn (f) ->
  fn
    0 -> 1
    1 -> 2
    n -> f.(n - 1) + f.(n - 2)
  end
end

fib = y.(proto_fib)
```

И така изведохме небезизвестния `Y` комбинатор. Това е функция от по висок ред,
която позволява функции без имена да поддържат рекурсия. Този изведен от нас го позволява
само за едно-аргументни функции. Освен това е вид `Y` комбинатор, по-известен като
`Z` комбинатор, защото `Elixir` не е lazy език и си изчислява аргументите преди да ги подаде на функцията.

Друго известно наименование на `Y` е _the fixed point combinator_. Тоест връща неподвижната точка
на функцията, която приема като аргумент. Неподвижна точка `x` за функция `f` е такава стойност, за която
`f(x) = x`. Нека да проверим:

```elixir
fib = y.(proto_fib)

proto_fib.(fib).(5)
13
fib.(5)
13
proto_fib.(proto_fib.(x)).(5)
13
```

Ако по горе `proto_fib` означим с `f`, a `y.(proto_fib)` с `x`, то `x` е неподвижна точка на `f`.
Това е така, защото равенството е изпълнено `f(x) = x = f(f(x)) = f(..(f(..(f(x))..))..)`.

Комбинаторът `Y` няма да ви трябва практически, ще работите с именовани функции, все пак, но
е една много красива конструкция. Работи някак магически и все пак няма никаква магия в него.
Разписването и разбирането му, никак не е безмислено упражнение.
Видяхме как абстрахираме и генерализираме концепции чрез функционално програмиране,
също се запознахме с няколко термина идващи от ламбда-смятането.

Това е всичко... засега.
